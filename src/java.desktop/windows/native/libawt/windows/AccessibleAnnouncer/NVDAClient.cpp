// Copyright 2000-2022 JetBrains s.r.o.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


#include "NVDAClient.h"
#include "nvda_autogenerated/nvdaController.h"  // nvdaControllerBindingHandle, nvdaController_*
#include <windows.h>
#include <stddef.h>                             // size_t           NOLINT(modernize-deprecated-headers)
#include <wchar.h>                              // wmemcpy          NOLINT(modernize-deprecated-headers)
#include <stdlib.h>                             // malloc, free     NOLINT(modernize-deprecated-headers)


NVDAClient* NVDAClient::getInstance()
{
    // TODO: ensure that the current thread is the awt thread

    static NVDAClient instance;

    if (!instance.isInitialized_) {
        return nullptr;
    }

    return &instance;
}


bool NVDAClient::testIfRunning() const
{
    error_status_t nvdaStatus = nvdaController_testIfRunning();
    if (nvdaStatus != 0) {
        return false;
    }
    return true;
}

bool NVDAClient::speakText(const wchar_t* text) const
{
    if (text == nullptr) {
        return false;
    }

    error_status_t nvdaStatus = nvdaController_speakText(text);
    if (nvdaStatus != 0) {
        // TODO: add some error handling
        return false;
    }

    return true;
}

bool NVDAClient::cancelSpeech() const
{
    error_status_t nvdaStatus = nvdaController_cancelSpeech();
    if (nvdaStatus != 0) {
        // TODO: add some error handling
        return false;
    }

    return true;
}

bool NVDAClient::brailleMessage(const wchar_t* text) const
{
    if (text == nullptr) {
        return false;
    }

    error_status_t nvdaStatus = nvdaController_brailleMessage(text);
    if (nvdaStatus != 0) {
        // TODO: add some error handling
        return false;
    }

    return true;
}


namespace ipcUtils
{
    namespace impl
    {
        static constexpr size_t wStrLen(const wchar_t *const str)
        {
            if (str == nullptr) return 0;
            if (*str == 0) return 0;
            return 1 + wStrLen(str + 1);
        }
    }


    /**
     * Writes sessionId + "." + desktopName to @p buf if its @p charsCapacity is big enough.
     *
     * @return Number of wide characters written if successful or 0 otherwise
     */
    static size_t generateDesktopSpecificNamespace(wchar_t* buf, size_t charsCapacity)
    {
        // TODO: remove the commented out block below when it will become useless
        /*DWORD sessionId=0;
        ProcessIdToSessionId(GetCurrentProcessId(),&sessionId);
        HANDLE hDesk=GetThreadDesktop(GetCurrentThreadId());
        wchar_t deskName[32];
        GetUserObjectInformationW(hDesk,UOI_NAME,deskName,sizeof(deskName),nullptr);
        wostringstream s;
        s<<sessionId<<"."<<deskName;
        size_t len=s.str().length();
        if(!buf||(cch==0)) return len;
        wcsncpy(buf,s.str().c_str(),cch);
        return min(len,cch);*/

        if ((buf == nullptr) || (charsCapacity < 1)) {
            return 0;
        }

        DWORD sessionId = 0;
        if (!ProcessIdToSessionId(GetCurrentProcessId(), &sessionId)) {
            return 0;
        }

        const HANDLE hDesk = GetThreadDesktop(GetCurrentThreadId());
        if (hDesk == nullptr) {
            return 0;
        }

        size_t result = 0;

        { // writing sessionId + "."
            const int charsWritten = swprintf(buf, charsCapacity, L"%llu.", static_cast<unsigned long long>(sessionId));
            if (charsWritten < 1) {
                return 0;
            }

            buf += charsWritten;
            charsCapacity -= charsWritten;
            result += charsWritten;
        }

        { // writing desktopName
            DWORD bytesWritten;
            if (!GetUserObjectInformationW(hDesk, UOI_NAME, buf, charsCapacity * sizeof(*buf), &bytesWritten)) {
                return 0;
            }
            const size_t charsWritten = bytesWritten / sizeof(*buf) + bytesWritten % sizeof(*buf);

            buf += charsWritten;
            charsCapacity -= charsWritten;
            result += charsWritten;
        }

        return result;
    }

    /**
     * Writes "ncalrpc:[NvdaCtlr." + generateDesktopSpecificNamespace(...) + "]\0" to @p buf if its @p charsCapacity is big enough.
     *
     * @return Number of wide characters written (not counting the terminating null wide character) if successful or 0 otherwise
     */
    static size_t generateRpcStringBinding(wchar_t* buf, size_t charsCapacity)
    {
        if (buf == nullptr) {
            return 0;
        }

        constexpr const wchar_t* prefix = L"ncalrpc:[NvdaCtlr.";
        constexpr size_t prefixLength = impl::wStrLen(prefix);

        constexpr const wchar_t* postfix = L"]";
        constexpr size_t postfixLength = impl::wStrLen(postfix) + 1; // +1 is for the null-terminator

        constexpr size_t prefixPostfixLength = prefixLength + postfixLength;
        if (charsCapacity <= prefixPostfixLength) {
            // there is no space for generateDesktopSpecificNamespace
            return 0;
        }

        charsCapacity -= prefixPostfixLength;

        (void)wmemcpy(buf, prefix, prefixLength);
        buf += prefixLength;

        size_t namespaceLen = generateDesktopSpecificNamespace(buf, charsCapacity);
        if (namespaceLen < 1) {
            // failed to generate
            return 0;
        } else if (buf[namespaceLen - 1] == 0) {
            --namespaceLen; // truncate a null-terminator
        }
        buf += namespaceLen;

        (void)wmemcpy(buf, postfix, postfixLength);

        return prefixPostfixLength - 1 + namespaceLen; // -1 is for skipping the null-terminator
    }
} // namespace ipcUtils


// https://learn.microsoft.com/en-us/windows/win32/rpc/how-memory-is-allocated-and-deallocated
// TODO: move midl_user_allocate, midl_user_free to somewhere

_Must_inspect_result_ _Ret_maybenull_ _Post_writable_byte_size_(size)
void* __RPC_USER midl_user_allocate(_In_ size_t size)
{
    return malloc(size);
}

void __RPC_USER midl_user_free(_Pre_maybenull_ _Post_invalid_ void* p)
{
    free(p);
}


NVDAClient::NVDAClient()
    : isInitialized_(false)
{
    // TODO: remove the commented out block below when it will become useless
    /*wchar_t desktopSpecificNamespace[64];
    generateDesktopSpecificNamespace(desktopSpecificNamespace,ARRAYSIZE(desktopSpecificNamespace));
    wstringstream s;
    s << L"ncalrpc:[NvdaCtlr." << desktopSpecificNamespace << L"]";
    auto wstr = s.str();
    const auto rpcWstr = RPC_WSTR(wstr.c_str());
    RPC_STATUS status = RpcBindingFromStringBinding(rpcWstr, &nvdaControllerBindingHandle);
    if (RPC_S_OK != status) {
        return FALSE;
    }*/

    constexpr size_t rpcStringBindingCapacity = 128;
    wchar_t rpcStringBinding[rpcStringBindingCapacity];

    const size_t rpcStringBindingLen = ipcUtils::generateRpcStringBinding(rpcStringBinding, rpcStringBindingCapacity);
    if (rpcStringBindingLen < 1) {
        return;
    }

    const RPC_WSTR castedRpcStringBinding = reinterpret_cast<RPC_WSTR>(&rpcStringBinding[0]);
    RPC_STATUS rpcStatus = RpcBindingFromStringBindingW(castedRpcStringBinding, &nvdaControllerBindingHandle);
    if (rpcStatus != RPC_S_OK) {
        return;
    }

    isInitialized_ = true;
}

NVDAClient::~NVDAClient() noexcept
{
    if (isInitialized_) {
        isInitialized_ = false;
        (void)RpcBindingFree(&nvdaControllerBindingHandle);
    }
}
